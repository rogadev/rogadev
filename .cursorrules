# SvelteKit Project Rules

## Svelte 5 Syntax Requirements

### Always use Svelte 5 syntax in .svelte files:

- Use `$state()` for reactive state instead of `let` declarations with `$:`
- Use `$derived()` for computed values instead of `$:` reactive statements
- Use `$effect()` for side effects instead of `$:` reactive statements
- Use `$props()` for component props instead of `export let`
- Use `$bindable()` for two-way binding props
- Use the new event handler syntax `onclick={handler}` instead of `on:click={handler}`
- Use snippet syntax `{#snippet name(params)}...{/snippet}` instead of slots when appropriate
- Use `{@render snippet()}` to render snippets
- Use `{@render children()}` instead of `<slot />` for content projection
- Prefer the new `mount()` and `unmount()` functions for lifecycle management
- Use `untrack()` for running code without creating dependencies

### Runes Mode Declaration:

When creating components that might be ambiguous about whether they use runes or legacy mode, add the explicit runes declaration at the top of the file:

```svelte
<svelte:options runes={true} />

<script>
	// Component code using runes...
</script>
```

**Use this directive when:**

- The component syntax could be interpreted as either runes or legacy mode
- During migration when mixing legacy and runes components in the same codebase
- For explicit documentation/clarity in complex components
- When working with components that don't use obvious runes syntax (like simple prop-only components)

### Component Structure:

```svelte
<svelte:options runes={true} />

<script>
	// Import statements
	import type { Snippet } from 'svelte';

	// Props using $props()
	let {
		propName = defaultValue,
		children,
		...restProps
	} = $props<{
		propName?: string;
		children?: Snippet;
	}>();

	// State using $state()
	let count = $state(0);

	// Derived values using $derived()
	let doubled = $derived(count * 2);

	// Effects using $effect()
	$effect(() => {
		// side effect logic
	});

	// Functions and other logic
</script>

<!-- Template -->
<div>
	{@render children?.()}
</div>
```

### Snippet and Children Typing:

**Preferred approach - Regular import:**

```svelte
<script>
	import type { Snippet } from 'svelte';

	let { children, headerSnippet, footerSnippet } = $props<{
		children?: Snippet;
		headerSnippet?: Snippet;
		footerSnippet?: Snippet;
	}>();
</script>
```

**Alternative approach - Inline import:**

```svelte
<script>
	let { children, headerSnippet } = $props<{
		children?: import('svelte').Snippet;
		headerSnippet?: import('svelte').Snippet;
	}>();
</script>
```

**When to use each approach:**

- **Regular import**: Use when you have multiple snippet props or when the component will likely be extended with more snippets
- **Inline import**: Use for simple components with only one snippet prop, or when you want to minimize imports

**Key typing rules:**

- Always make snippet props optional with `?` unless they are required
- Use consistent naming: `children` for default content, `[name]Snippet` for named snippets
- Always use optional chaining when rendering: `{@render children?.()}`

## Deprecation Rules and Fixes

### When encountering Svelte deprecation linting errors:

1. **Immediately fix the deprecation** using the Svelte 5 equivalent
2. **Document the fix** by adding the pattern to this rules file
3. **Update this section** with the specific deprecation and its modern replacement

### Known Deprecation Patterns (update as we encounter them):

#### Slots → Children Rendering

```svelte
<!-- OLD (deprecated): -->
<div>
	<slot />
</div>

<!-- Also deprecated: -->
<div>
	<slot name="header" />
</div>

<!-- NEW (Svelte 5): -->
<script>
	import type { Snippet } from 'svelte';

	let { children } = $props<{
		children?: Snippet;
	}>();
</script>
<div>
	{@render children?.()}
</div>

<!-- For named slots, use snippets: -->
<script>
	import type { Snippet } from 'svelte';

	let { headerSnippet, children } = $props<{
		headerSnippet?: Snippet;
		children?: Snippet;
	}>();
</script>
<div>
	{@render headerSnippet?.()}
	{@render children?.()}
</div>
```

**Migration Pattern:**

- Replace `<slot />` with `{@render children?.()}`
- Replace named slots `<slot name="xyz" />` with snippet props `{@render xyzSnippet?.()}`
- Always destructure `children` from `$props()` when using content projection
- Use optional chaining (`?.()`) when rendering snippets to handle undefined snippets
- Name snippet props consistently with `Snippet` suffix (e.g., `headerSnippet`, `footerSnippet`)
- Import `Snippet` type from 'svelte' for proper TypeScript support
- Always make snippet props optional unless they are explicitly required

#### Reactive Statements → Modern Equivalents

```javascript
// OLD (deprecated):
$: doubled = count * 2;

// NEW (Svelte 5):
let doubled = $derived(count * 2);
```

#### Component Props → $props()

```javascript
// OLD (deprecated):
export let name;
export let age = 25;

// NEW (Svelte 5):
let { name, age = 25 } = $props();
```

#### Event Handlers → New Syntax

```svelte
<!-- OLD (deprecated): -->
<button on:click={handleClick}>

<!-- NEW (Svelte 5): -->
<button onclick={handleClick}>
```

#### Event Dispatching → Callback Props

```javascript
// OLD (deprecated):
import { createEventDispatcher } from 'svelte';
const dispatch = createEventDispatcher();
$effect(() => {
	dispatch('eventName', eventData);
});

// NEW (Svelte 5):
let { onEventName } = $props();
$effect(() => {
	onEventName?.(eventData);
});
```

**Usage Pattern:**

- Instead of dispatching events, accept callback props
- Name callback props with `on` prefix (e.g., `onPageChange` instead of dispatching `pageChange`)
- Call the callback directly with the data (no `.detail` property needed)
- Always use optional chaining (`?.`) when calling callbacks to handle undefined callbacks

#### Lifecycle → Effects

```javascript
// OLD (deprecated):
import { onMount, onDestroy } from 'svelte';
onMount(() => {
	/* logic */
});

// NEW (Svelte 5):
$effect(() => {
	// mount logic
	return () => {
		// cleanup logic (replaces onDestroy)
	};
});
```

## Code Quality Rules

### TypeScript Usage:

- Always use TypeScript in .ts and .svelte files
- Properly type component props and state
- Use proper typing for event handlers
- Import `Snippet` type from 'svelte' for children and snippet props

### File Organization:

- Place reusable components in `src/lib/components/`
- Place utilities in `src/lib/utils/`
- Place types in `src/lib/types/`
- Use proper SvelteKit routing in `src/routes/`

### Styling:

- Use Tailwind CSS classes as configured
- Follow the existing prettier and ESLint configuration
- Maintain consistent code formatting

## Development Workflow

### When fixing deprecation warnings:

1. Identify the deprecated pattern
2. Replace with Svelte 5 equivalent
3. Test the functionality
4. Update this .cursorrules file with the pattern
5. Commit the changes together

### Linting Process:

- Run `pnpm lint` to check for issues
- Run `pnpm check` for Svelte-specific checks
- Fix any deprecation warnings immediately using Svelte 5 patterns
- Document new patterns in this file

## Additional Notes

- Always prioritize Svelte 5 patterns over legacy Svelte syntax
- When in doubt about Svelte 5 syntax, refer to the official Svelte 5 documentation
- Keep this rules file updated as we encounter and fix more deprecation patterns
- Ensure all code changes maintain backward compatibility where needed
- **NEVER use `<slot />` - always use `{@render children?.()}` instead**
